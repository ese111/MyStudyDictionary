# 객체지향

## 객체지향이란
- 객체 지향 프로그래밍(영어: Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 
- 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.(책임과 역할, 협력)
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 
- 소프트웨어 개발과 유지보수를 좋게한다.
## 역사
초기의 프로그래밍은 절차지향적이었다.  
입력을 받아서 순서대로 처리하고 결과를 내는 방식으로 개발이 진행되었다.  
그러나 컴퓨터가 발전하고 프로그램이 커지면서 점점 만드사람 조차도 순서를 알 수 없을 정도로 꼬여가는 절차지향적 방식의 프로그램을 유지보수하거나 고치는 일은 너무나도 힘든 일이었고,  
프로그램이 어떤 데이터를 다루는지 조차 알기가 힘든 모습을 띄게 되었다.  
이 문제를 해결하기 위해 에츠허르 다익스트라가 1968년 GOTO문의 해로움이라는 논문에서 프로그램을 프로시저(procedure) 단위로 나누고 프로시저끼리 호출을 하는 구조적 프로그래밍 방식을 제안하면서 이러한 위기를 벗어나게 된다. 프로그램이라는 큰 문제를 해결하기 위해 그것을 몇개의 작은 문제들로 나누어 해결하기 때문에 하향식(Top-down) 방식이라고도 한다.  
하지만 함수는 데이터의 처리방식을 구조화하고 데이터 자체는 구조화하지 못했고 다시 여러 단점이 나타나게 된다.  
그래서 작은 객체부터 만들어나가며 그 객체들을 조합해 큰 객체를 만드는 객체지향이 시작되게 된다.

## 요소
- ### 캡슐화
- 객체의 필드(속성), 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 말한다.
- 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.

    - #### 정보은닉
    - 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것이다. 
    - 내부의 구현은 감추고 모듈 내에서의 응집도를 높이며, 외부로의 노출을 최소화하여 모듈 간의 결합도를 떨어뜨려 유연함과 유지보수성을 높이는 개념
    - 클래스 외부에서는 바깥으로 노출된 특정 메소드에만 접근이 가능하며 클래스 내부에서 어떤 식으로 처리가 이루어지는지는 알지 못하도록 설계된다.
        - 접근제한자
        - public: 클래스의 외부에서 사용 가능하도록 노출시키는 것이다.
        - protected: 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것이다.
        - private: 클래스의 내부에서만 사용되며 외부로 노출되지 않는다.
```kotlin
class student {
	private var name: String = ""
	private var code: String = ""
	private var age: Int = 0

	//getter
	public fun getName() {
		return id;
	}
	public fun getCode() {
		return pw;
	}
	public fun getAge() {
		return age;
	}

	//setter
	public fun setName(name: String ) {
		this.id = id;
	}
	public fun setCode(code: String ) {
		this.pw = pw;
	}
	public fun setAge(age: Int) {
		this.age = age;
	}
}
```

- ### 상속
- 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것
- 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의(오버라이딩(overriding))
- 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.
```kotline
open class Parent {
    open fun money() {
        println("100")
    }

}
class Child : Parent() {
    override fun money() {
        println("200")
    }
}
fun main() {
    val child = Child()
    child.money() 
}
```
- ### 다형성
- 이름은 같지만 매개변수가 다르거나 다른 동작을 하도록 하는 것
    - 오버로딩
    - 매개변수를 달리해서 같은이름의 함수를 정의하는것
    ```kotlin
    fun number(num: Int){
        println(num)
    }
    fun number(x: Int, y: Int){
        println(x+y)
    }
    ```


참고

<https://radait.tistory.com/5>
<https://smoh.tistory.com/247>

