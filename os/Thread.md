# Thread
CPU 실행 단위
- 실행히는 모든 프로그램을 전부 프로세스화하면 비효율 적이기 떄문에 스레드를 만들어 주소공간을 공유한다
## 구성
- program counter
- register set
- stack space
## 스레드끼리 공유(task)
- code section
- data section
- OS resources

## 장점
- 하나의 서버 스레드가 waiting상태인 동안에도 동일한 테스크 내의 다른 스레드가 실행되어 빠른 처리 가능
- 스레드끼리 협력하여 성능향상
- 병렬성 증가
- 자원 공유
- 프로세스하나를 만드는거 보다 30배 효율적

## 멀티 스레딩
- 하나의 프로세스 내에 여러개의 스레드를 허용하는 환경
- 멀티 스레딩을 지원하는 운영체제에선 프로세스가 아닌 스레드 단위로 스케줄링
- 하나의 프로세스 내의 여러 스레드들은 프로세스에게 할당된 자원을 공유
- 프로세스에 비해 관리 비용이 적음
- 스레드 간의 context switch 로 인한 오버헤드는 프로세스간의 전환 오버헤드보다 훨씬 적음
## 영역 공유
- 스레드는 프로세스의 자원을 공유하지만, 두 스레드가 각자 실행하는 곳이 다름
- 다른 스택 포인터를 가지고 있다.
- 스택 영역은 따로있다.


## 다중 프로그래밍과 멀티 스레딩의 차이
- 다중 프로그래밍은 두 개 이상의 프로세스를 번갈아 가며 실행하는 것
- 멀티 스레딩은 하나의 프로세스 내에서 여러 스레드를 번갈아가며 실행하는 것

## 스케줄링(Scheduling)
- 메모리에 적재된 프로그램을 CPU가 실행 할 수 있게 운영체제가 프로세스나 스레드를 CPU에 효율적으로 할당하게 하는것
- 스케줄러는 제한된 자원을 여러 프로세스가 효율적으로 사용하도록 다양한 정책을 가지고 CPU를 할당 
    - 정책이란 어떤 프로세스 또는 스레드에게 어떤 순서로 또는 어떤 기준으로 CPU를 할당할지를 결정하는 방법
    - 프로세스 스케줄링과 스레드 스케줄링은 할당 대상만 다를 뿐 방식은 동일

## 프로세스 스케줄러
- 프로세스 선택 기준을 정하는 정책 부분과 선택된 프로세스에게 CPU를 할당하는 디스패처(dispatcher) 부분으로 구성
- 준비 상태의 프로세스에만 CPU를 할당
- 준비 상태의 프로세스가 대기하는 공간이 준비 큐(ready queue)
- 프로세스 스케줄링은 준비 큐에 들어 있는 여러 프로세스 중 정책에 따라 하나의 프로세스를 선택하여 CPU를 할당하는 행위

## 선점과 비선점
- 선점(preemptive)
    - 선점 방식이란 실행 중인 프로세스가 강제적으로 실행권을 빼앗기는 것
    - 새로운 프로세스가 생겼을때
        - 새 프로세스가 우선순위가 높을 때
    - 대기에서 준비 상태로 들어갈때
        - 인터럽트나 입출력이 끝난 프로세스가 실행 될 때
    - 실행에서 준비상태가 될 때
        - 타이머가 개입
    - 에러나 외부요인으로 종료
- 비선점(non-preemptive)
    - 실행 중인 프로세스가 자신의 실행권을 자발적으로 내려놓는 것
    - 실행 중인 프로세스가 종료될 경우
    - 실행 중인 프로세스가 대기가 될 경우
        - 사용자 프로그램이 할 수 없는 일을 해야할 때


## 스케줄링 정책
- CPU 이용률
    - 주어진 시간에 대한 CPU 사용 시간
- 처리율
    - 단위 시간당 처리된 프로세스 개수
- 반환시간
    - 프로세스가 생성된 후 종료될 때 까지 소요된 시간
- 대기시간
    - 프로세스가 준비 상태에서 소요된 시간
- 응답시간
    - 어떤 사건이 발생한 후 첫 번째 응답이 나오는 데 소요된 시간
- CPU 이용률과 처리율을 최대로 하고 나머지를 최소로 하는 것이 가장 좋음
- 모든 요소를 최적화할 순 없으므로 필요 시스템마다 다르게 설계 

- ## 선입 선처리 스케줄링(First-Come First-Served)
    - 준비 큐에 등록된 여러 프로세스 중 하나를 선택하는 과정
    - 큐에 등록된 순서 그대로 프로세스를 처리하는 가장 기본적인 정책
    - ### 주의
        - 프로세스가 생성된 순서가 아닌 준비 큐에 등록된 순서
        - 해당 정책은 순서대로 처리하므로 실행 중인 프로세스가 다른 프로세스에 의해 선점될 수 없음
        - 대표적인 비선점 방식의 스케줄링
        - 프로세스는 사용 시간이 짧음에도 오래 기다려야 하는 비효율적인 특징 (호송 효과(convoy effect)) - 호송 효과로 인한 평균 대기 시간이 길어질 수 있다는 단점

- ## 순환 처리 스케줄링(Round-Robin)
    - 모든 프로세스에 CPU 할당 시간을 부여하여 CPU 사용 시간을 제한하는 시분할 시스템(time-sharing system)을 위해 개발된 선점 방식의 스케줄링 정책
    - 따라서 RR 스케줄링 정책은 모든 프로세스에 적절한 CPU 할당 시간을 부여
    - 준비 큐에 등록된 순서대로 프로세스를 처리
    - 만약 할당된 시간을 모두 사용하였을 경우 다음 차례의 프로세스에 의해 선점, 선점된 프로세스는 준비 큐의 맨 뒤에 등록

    - ### 주의 
        - RR 스케줄링 정책에선 각 CPU 할당 시간이 너무 많으면 FCFS 정책과 같이 호송 효과가 발생
        - 적으면 빈번한 context switch로 인한 오버헤드가 발생
        - CPU 할당 시간 분배가 중요

- ### 다단계 피드백 큐 스케줄링
    - 다단계 큐라는 정책에서 피드백(특정 동작)이 추가된 정책
    - 다단계 큐는 여러개의 준비 큐를 사용
    - #### 순서
        - 우선순위가 높은 큐에는 상대적으로 적은 CPU 할당시간을, 우선순위가 낮은 큐에는 상대적으로 많은 CPU 할당시간을 부여
        - 초기엔 모든 프로세스를 첫 번째 큐(우선 순위가 가장 높은 큐)에 등록하여 차례대로 실행
        - 실행 중인 프로세스가 주어진 CPU 할당시간 내에 종료되지 않을 경우 다음 차례의 프로세스에 의해 선점
        - 선점된 프로세스는 동일한 큐의 맨 뒤에 등록되는 것이 아닌 한 단계 낮은 우선순위의 준비 큐에 등록
        - 많은 CPU 사용 시간을 요구하는 프로세스들은 점점 낮은 단계의 큐로 이동
    - #### 다단계 큐
    - 큐에 잇는 프로세마다 우선 순위가 있음
    - 우선 순위대로 처리
        - ##### 주의
        - 기아(Starvation) 현상
            - 계속해서 우선순위가 높은 프로세스가 들어오면, 우선순위가 낮은 프로세스는 무한정 대기만 하여 절대 실행되지 않는 현상 이러한 현상
            - 에이징(aging)으로 해결
